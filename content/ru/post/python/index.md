---
# Documentation: https://wowchemy.com/docs/managing-content/

title: Python
subtitle: Язык программирования Python
summary: В этом посте я расскажу вам о Python.
authors: [Garut A. I.]
tags: []
categories: []
date: 2022-05-28T13:05:31+03:00
lastmod: 2022-05-28T13:05:31+03:00
featured: false
draft: false

# Featured image
# To use, add an image named `featured.jpg/png` to your page's folder.
# Focal points: Smart, Center, TopLeft, Top, TopRight, Left, Right, BottomLeft, Bottom, BottomRight.
image:
  caption: ""
  focal_point: ""
  preview_only: false

# Projects (optional).
#   Associate this post with one or more of your projects.
#   Simply enter your project's folder or file name without extension.
#   E.g. `projects = ["internal-project"]` references `content/project/deep-learning/index.md`.
#   Otherwise, set `projects = []`.
projects: []
---

![Python_logo](python-logo.png)

# Python

## Базовая информация

Python — это высокоуровневый интерпретируемый язык программирования общего назначения. Философия его дизайна делает упор на удобочитаемость кода с использованием значительных отступов.

Python имеет динамическую типизацию и сборку мусора. Он поддерживает несколько парадигм программирования, включая структурированное (особенно процедурное), объектно-ориентированное и функциональное программирование. Его часто называют языком «с батарейками» из-за обширной стандартной библиотеки.

Гвидо ван Россум начал работать над Python в конце 1980-х годов как преемник языка программирования ABC и впервые выпустил его в 1991 году как Python 0.9.0. Python 2.0 был выпущен в 2000 году и представил новые функции, такие как понимание списков, сборка мусора с обнаружением циклов, подсчет ссылок и поддержка Unicode. Python 3.0, выпущенный в 2008 году, был основной версией, не имеющей полной обратной совместимости с более ранними версиями. Python 2 был прекращен с версии 2.7.18 в 2020 году.

## История

Python был задуман в конце 1980-х Гвидо ван Россумом из Centrum Wiskunde & Informatica (CWI) в Нидерландах как преемник языка программирования ABC, который был вдохновлен SETL, способным обрабатывать исключения и взаимодействовать с операционной системой Amoeba. Его реализация началась в декабре 1989 года. Ван Россум брал на себя исключительную ответственность за проект в качестве ведущего разработчика до 12 июля 2018 года, когда он объявил о своем «постоянном отпуске» от своих обязанностей «доброжелательного диктатора на всю жизнь» Python. сообщество, дарованное ему, чтобы отразить его долгосрочную приверженность в качестве главного лица, принимающего решения по проекту. В январе 2019 года активные разработчики ядра Python избрали Руководящий совет из пяти человек для руководства проектом.

Python 2.0 был выпущен 16 октября 2000 г. и содержал множество важных новых функций. Python 3.0, выпущенный 3 декабря 2008 г., многие из его основных функций перенесены в Python 2.6.x и 2.7.x. Релизы Python 3 включают утилиту 2to3, которая автоматизирует перевод кода Python 2 в Python 3.

Окончание срока службы Python 2.7 первоначально было назначено на 2015 год, а затем было перенесено на 2020 год из-за опасений, что большой объем существующего кода нельзя будет легко перенести на Python 3. Никаких дополнительных исправлений безопасности или других улучшений выпускаться не будет. для этого. С окончанием срока службы Python 2 поддерживались только Python 3.6.x и более поздние версии. Позже поддержка 3.6 также была прекращена. В 2021 году Python 3.9.2 и 3.8.8 были ускорены, поскольку все версии Python (включая 2.7) имели проблемы с безопасностью, приводящие к возможному удаленному выполнению кода и отравлению веб-кэша.

В 2022 году Python 3.10.4 и 3.9.12 были ускорены, как и более старые выпуски, включая 3.8.13 и 3.7.13, из-за множества проблем с безопасностью в 2022 году. Python 3.9.13 — это последняя версия 3.9, а с этого момента — 3.9. (и старше; 3.8 и 3.7) будут получать только обновления безопасности.

## Синтаксис и семантика
Основная статья: синтаксис и семантика Python
Python должен быть легко читаемым языком. Его форматирование визуально незагромождено и часто использует английские ключевые слова там, где другие языки используют знаки препинания. В отличие от многих других языков, он не использует фигурные скобки для разделения блоков, а точки с запятой после операторов разрешены, но редко используются. В нем меньше синтаксических исключений и особых случаев, чем в C или Pascal.

### Отступ
Основная статья: синтаксис и семантика Python § Отступы
Python использует пробельные отступы, а не фигурные скобки или ключевые слова, для разделения блоков. Увеличение отступа происходит после определенных утверждений; уменьшение отступа означает конец текущего блока.[81] Таким образом, визуальная структура программы точно отражает ее семантическую структуру. Эту особенность иногда называют правилом вне игры. Некоторые другие языки используют отступ таким образом; но в большинстве случаев отступ не имеет семантического значения. Рекомендуемый размер отступа — четыре пробела.

### Операторы и поток управления
Заявления Python включают:

Оператор присваивания с использованием одного знака равенства =
Оператор if, который условно выполняет блок кода вместе с else и elif (сокращение от else-if).
Оператор for, который выполняет итерацию по итерируемому объекту, записывая каждый элемент в локальную переменную для использования прикрепленным блоком.
Оператор while, который выполняет блок кода до тех пор, пока его условие истинно.
Оператор try, который позволяет перехватывать и обрабатывать исключения, возникающие в прикрепленном к нему блоке кода, с помощью предложений exclude (или новый синтаксис, exclude* в Python 3.11 для групп исключений); это также гарантирует, что код очистки в блоке finally всегда выполняется независимо от того, как блок выходит.
Оператор повышения, используемый для возбуждения указанного исключения или повторного возбуждения перехваченного исключения.
Оператор класса, который выполняет блок кода и прикрепляет свое локальное пространство имен к классу для использования в объектно-ориентированном программировании.
Оператор def, определяющий функцию или метод.
Оператор with, который заключает в себе блок кода в менеджере контекста (например, получение блокировки перед ее запуском, а затем снятие блокировки или открытие и закрытие файла), разрешает получение ресурсов при инициализации (RAII) — подобное поведение и замена распространенной идиомы try/finally
Оператор break, который выходит из цикла
Оператор continue, который пропускает текущую итерацию и продолжает следующую.
Оператор del, который удаляет переменную — удаляет ссылку из имени на значение и выдает ошибку, если на переменную ссылаются до ее переопределения.
Оператор pass, выступающий в роли NOP, синтаксически необходим для создания пустого блока кода.
Оператор assert, используемый при отладке для проверки условий, которые должны применяться.
Оператор yield, который возвращает значение из функции-генератора (а также оператора); используется для реализации сопрограмм
Оператор return, используемый для возврата значения из функции.
Оператор импорта, используемый для импорта модулей, функции или переменные которых можно использовать в текущей программе.
Оператор присваивания (=) связывает имя как ссылку на отдельный динамически выделяемый объект. Переменные впоследствии могут быть в любой момент связаны с любым объектом. В Python имя переменной является общим держателем ссылки без фиксированного типа данных; однако он всегда ссылается на некоторый объект с типом. Это называется динамической типизацией — в отличие от языков со статической типизацией, где каждая переменная может содержать значение только определенного типа.

Python не поддерживает оптимизацию хвостовых вызовов или первоклассные продолжения, и, по словам ван Россума, никогда не будет. Однако лучшая поддержка функций, подобных сопрограммам, обеспечивается за счет расширения генераторов Python. До версии 2.5 генераторы были ленивыми итераторами; данные были переданы однонаправленно из генератора. Начиная с Python 2.5, можно передавать данные обратно в функцию-генератор; а начиная с версии 3.3 его можно передавать через несколько уровней стека.

### Выражения
Некоторые выражения Python похожи на выражения в таких языках, как C и Java, а некоторые нет:

Сложение, вычитание и умножение одинаковы, но поведение деления отличается. В Python существует два типа делений: деление на пол (или целочисленное деление) // и деление с плавающей запятой. Python также использует оператор ** для возведения в степень.
Инфиксный оператор @. Он предназначен для использования такими библиотеками, как NumPy, для умножения матриц.
Синтаксис :=, называемый «оператором моржа», был представлен в Python 3.8. Он присваивает значения переменным как часть более крупного выражения.
В Python == сравнивает по значению, в отличие от Java, которая сравнивает числовые значения по значению и объекты по ссылке. Оператор is в Python может использоваться для сравнения идентификаторов объектов (сравнение по ссылке), а сравнения могут быть объединены в цепочку, например, a <= b <= c.
Python использует и, или, и не как логические операторы, а не символические операторы &&, ||, ! на Яве и С.
Python имеет тип выражения, называемый пониманием списка, а также более общее выражение, называемое генераторным выражением.
Анонимные функции реализованы с помощью лямбда-выражений; однако в каждом теле может быть только одно выражение.
Условные выражения записываются как x if c else y (порядок операндов отличается от оператора c ? x : y, общего для многих других языков).
Python делает различие между списками и кортежами. Списки записываются как [1, 2, 3], являются изменяемыми и не могут использоваться в качестве ключей словарей (ключи словарей должны быть неизменяемыми в Python). Кортежи, записанные как (1, 2, 3), являются неизменяемыми и поэтому могут использоваться в качестве ключей словарей при условии, что все элементы кортежа неизменны. Оператор + можно использовать для объединения двух кортежей, что не изменяет их содержимое напрямую, а создает новый кортеж, содержащий элементы обоих. Таким образом, если переменная t изначально равна (1, 2, 3), выполнение t = t + (4, 5) сначала оценивает t + (4, 5), что дает (1, 2, 3, 4, 5) , который затем присваивается обратно t, тем самым эффективно «модифицируя содержимое» t, при этом соответствуя неизменной природе объектов кортежей. Скобки необязательны для кортежей в однозначном контексте.
В Python реализована последовательная распаковка, при которой несколько выражений, каждое из которых оценивает что-либо, что может быть назначено (переменной, доступному для записи свойству и т. д.), связываются таким же образом, как формирующие литералы кортежа, и в целом располагаются слева. Сторона знака равенства в операторе присваивания. Оператор ожидает итерируемый объект справа от знака равенства, который производит то же количество значений, что и предоставленные записываемые выражения; при повторении по ним он присваивает каждое из полученных значений соответствующему выражению слева.
В Python есть оператор «строкового формата» %, который функционирует аналогично строкам формата printf в C, например. "spam=%s egg=%d" % ("blah", 2) оценивается как "spam=blah egg=2". В Python 2.6+ и 3+ это было дополнено методом format() класса str, например. "спам={0} яйца={1}".format("бла", 2). В Python 3.6 добавлены «f-строки»: spam = «blah»; яйца = 2; f'spam={спам} яйца={яйца}'.
Строки в Python можно объединять, «добавляя» их (с тем же оператором, что и для добавления целых чисел и чисел с плавающей запятой), например. «спам» + «яйца» возвращает «спамеггсы». Если строки содержат числа, они добавляются как строки, а не целые числа, например. «2» + «2» возвращает «22».
Python имеет различные строковые литералы:
Разделяется одинарными или двойными кавычками. В отличие от оболочек Unix, Perl и языков, на которые повлиял Perl, одинарные и двойные кавычки работают одинаково. Оба используют обратную косую черту (\) в качестве escape-символа. Интерполяция строк стала доступна в Python 3.6 как «форматированные строковые литералы».
Тройные кавычки (начинающиеся и заканчивающиеся тремя одинарными или двойными кавычками), которые могут охватывать несколько строк и функционировать, как здесь, документы в оболочках, Perl и Ruby.
Варианты необработанных строк, обозначаемые префиксом строкового литерала с помощью r. Escape-последовательности не интерпретируются; следовательно, необработанные строки полезны там, где распространены буквальные обратные косые черты, такие как регулярные выражения и пути в стиле Windows. (Сравните "@-цитирование" в C#.)
Python имеет индексы массивов и выражения нарезки массивов в списках, обозначаемые как [ключ], [начало: стоп] или [начало: стоп: шаг]. Индексы отсчитываются от нуля, а отрицательные индексы относятся к концу. Срезы берут элементы от начального индекса до конечного индекса, но не включают его. Третий параметр среза, называемый шагом или шагом, позволяет пропускать элементы и менять их местами. Индексы срезов могут быть опущены, например, a[:] возвращает копию всего списка. Каждый элемент среза является мелкой копией.
В Python строго проводится различие между выражениями и операторами, в отличие от таких языков, как Common Lisp, Scheme или Ruby. Это приводит к дублированию некоторых функций. Например:

Понимание списков против циклов for
Условные выражения и блоки if
Встроенные функции eval() и exec() (в Python 2 exec — это инструкция); первый для выражений, второй для утверждений
Операторы не могут быть частью выражения, поэтому списки и другие включения или лямбда-выражения, являющиеся выражениями, не могут содержать операторы. Частным случаем является то, что оператор присваивания, такой как a = 1, не может быть частью условного выражения условного оператора. Это имеет то преимущество, что позволяет избежать классической ошибки C, заключающейся в ошибочном принятии оператора присваивания = за оператор равенства == в условиях: if (c = 1) { ... } синтаксически допустимый (но, вероятно, непреднамеренный) код C, = 1: ... вызывает синтаксическую ошибку в Python.

### Методы
Методы объектов — это функции, присоединенные к классу объекта; синтаксис instance.method(аргумент) для обычных методов и функций является синтаксическим сахаром для Class.method(экземпляр, аргумент). Методы Python имеют явный параметр self для доступа к данным экземпляра, в отличие от неявного параметра self (или this) в некоторых других объектно-ориентированных языках программирования (например, C++, Java, Objective-C, Ruby). Python также предоставляет методы, часто называемые методами dunder (из-за того, что их имена начинаются и заканчиваются двойным подчеркиванием), позволяющие определяемым пользователем классам изменять способ их обработки собственными операциями, включая длину, сравнение, арифметические операции и преобразование типов.

### Ввод

Python использует утиную типизацию и имеет типизированные объекты, но нетипизированные имена переменных. Ограничения типа не проверяются во время компиляции; скорее, операции над объектом могут завершиться неудачно, что означает, что он не относится к подходящему типу. Несмотря на динамическую типизацию, Python является строго типизированным, запрещая операции, которые не определены четко (например, добавление числа в строку), вместо того, чтобы молча пытаться понять их смысл.

Python позволяет программистам определять свои собственные типы с помощью классов, которые чаще всего используются для объектно-ориентированного программирования. Новые экземпляры классов создаются путем вызова класса (например, SpamClass() или EggsClass()), а классы являются экземплярами типа метакласса (сам экземпляр самого себя), что позволяет осуществлять метапрограммирование и отражение.

До версии 3.0 в Python было два типа классов (оба использовали один и тот же синтаксис): старый стиль и новый стиль, текущие версии Python поддерживают только семантику нового стиля.

Долгосрочный план заключается в поддержке постепенного набора текста. Синтаксис Python позволяет указывать статические типы, но они не проверяются в реализации по умолчанию, CPython. Экспериментальная необязательная статическая проверка типов mypy поддерживает проверку типов во время компиляции.